package reversiassignment;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import reversiassignment.Board.Cellstate;

public class MiniMax {
	private Helper helper;

	public MiniMax(Helper h) {
		helper = h;
	}

	private int getScore(Board board) {
		int score = 0;
		Cellstate[][] b = board.getBoard();
		for (int i = 0; i < Board.SIZE; i++) {
			for (int j = 0; j < Board.SIZE; j++) {
				if (b[i][j] == Cellstate.BLACK)
					score++;
				else if (b[i][j] == Cellstate.WHITE)
					score--;
			}
		}
		return score;
	}
	

	public int maxDecision(GameNode node, int depth) {
		if (node.board.gameOver())
			return getScore(node.board);
		Cellstate color;
		if (node.board.getCellstate(node.pos.r, node.pos.c) == Cellstate.BLACK)
			color = Cellstate.WHITE;
		else
			color = Cellstate.BLACK;
		Set<Position> possibleMoves = node.board.getAdjs();
		int maxValue = Integer.MIN_VALUE;
		for (Position pos : possibleMoves) {
			Set<Position> flips = helper.evaluateMove(pos, color, node.board);
			if (!flips.isEmpty()) {
				Board newBoard = new Board(node.board.getBoard(), possibleMoves);
				newBoard.placeMarker(pos, color);
				newBoard.flipMarkers(flips, color);
				int tmp = maxDecision(new GameNode(newBoard, pos), depth--);
				if (tmp > maxValue) {
					maxValue = tmp;
				}
			}
		}
		return maxValue;
	}


}
