package reversiassignment;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import reversiassignment.Board.Cellstate;

public class MiniMax {
	private Cellstate currentPlayer;
	private Helper helper;
	private GameState root;

	public MiniMax(Board b, Cellstate c, Helper h) {
		currentPlayer = c;
		helper = h;
		root = new GameState(b, b.getScore(c), null, 0);
	}

	private void traverseTree(GameState parent) {
		Set<Position> adjs = parent.board.getAdjs();
		for (Position p : adjs) {
			System.out.println("Generating children for " + p.toString());
			Board newBoard = new Board(parent.board.getBoard(), parent.board.getAdjs());
			newBoard.placeMarker(p, currentPlayer);
			newBoard.flipMarkers(helper.evaluateMove(p, currentPlayer, newBoard), currentPlayer);
			GameState child = new GameState(newBoard, newBoard.getScore(currentPlayer), p, depth);
			parent.addChild(child);
			tr
		}
	}

	private void alpha() {

	}

	public Position maxDecision() {

		Board board = root.board;
		Iterator<Position> itr1 = board.getAdjs().iterator();
		Set<Position> flips;
		Position p;
		do {
			p = itr1.next();
			flips = helper.evaluateMove(p, currentPlayer, board);
		} while (flips.isEmpty() && itr1.hasNext());
		return p;

		// int maxScore = 0;
		// Position p = root.children.get(1).move;
		// for (GameState child : root.children) {
		// if (child.score >= maxScore)
		// p = child.move;
		// }
		// return p;
	}
}
